//! Butterworth filter of order 2.
//! Region of validity: cutoff ratio from 1.66e-04 to 4.00e-01 .
//! This file is autogenerated.
#![allow(clippy::style)]

use crate::{SisoIirFilter, StagedSisoIirFilter};

/// Minimum tabulated cutoff ratio
#[allow(dead_code)]
pub const MIN_CUTOFF_RATIO: f64 = 0.00016637957093869996;

/// Maximum tabulated cutoff ratio
#[allow(dead_code)]
pub const MAX_CUTOFF_RATIO: f64 = 0.4;

/// Initialise a Butterworth filter of order 2 by interpolating the coefficients from stored tables.
/// Cutoff ratio is the dimensionless ratio of the cutoff frequency to the sampling frequency.
/// Region of validity: cutoff ratio from 1.66e-04 to 4.00e-01
pub fn butter2(cutoff_ratio: f64) -> Result<SisoIirFilter<2>, &'static str> {
    let avals = &[&AVALS[0][..], &AVALS[1][..]];
    let cvals = &[&CVALS[0][..], &CVALS[1][..]];
    SisoIirFilter::new_interpolated(cutoff_ratio, &LOG10_CUTOFF_RATIOS, avals, cvals, &DVALS)
}

/// Initialise a two-stage Butterworth filter of combined order 2*2 by interpolating the coefficients from stored tables.
/// Cutoff ratio is the dimensionless ratio of the cutoff frequency to the sampling frequency.
/// Region of validity: cutoff ratio from 1.22e-04 to 3.65e-01
pub fn butter2_2stage(cutoff_ratio: f64) -> Result<StagedSisoIirFilter<2, 2>, &'static str> {
    // Look up the per-stage cutoff ratio corresponding to the desired combined cutoff
    let log10_root_cutoff_ratio = libm::log10(cutoff_ratio);

    if log10_root_cutoff_ratio < LOG10_ROOT2_CUTOFF_RATIOS[0]
        || log10_root_cutoff_ratio > *LOG10_ROOT2_CUTOFF_RATIOS.last().ok_or("Table size error")?
    {
        return Err("Selected cutoff ratio is outside the grid");
    }

    let log10_cutoff_ratio = interpn::MulticubicRectilinear::<'_, _, 2>::new(
        &[&LOG10_ROOT2_CUTOFF_RATIOS],
        &LOG10_CUTOFF_RATIOS,
        true,
    )?
    .interp_one(&[log10_root_cutoff_ratio])?;
    let cutoff_ratio = libm::pow(10.0, log10_cutoff_ratio);
    let filt = butter2(cutoff_ratio)?;
    Ok(StagedSisoIirFilter::new([filt, filt]))
}

/// [dimensionless] Log base-10 of cutoff ratios, to improve float precision during interpolation
#[rustfmt::skip]
static LOG10_CUTOFF_RATIOS: [f64; 30] = [-3.7789, -3.662315172712829, -3.5457303454256577, -3.429145518138487, -3.3125606908513157, -3.1959758635641444, -3.0793910362769736, -2.9628062089898024, -2.846221381702631, -2.72963655441546, -2.6130517271282887, -2.496466899841118, -2.3798820725539467, -2.2632972452667754, -2.1467124179796047, -2.0301275906924334, -1.9135427634052622, -1.796957936118091, -1.6803731088309197, -1.563788281543749, -1.4472034542565777, -1.3306186269694065, -1.2140337996822357, -1.0974489723950644, -0.9808641451078932, -0.864279317820722, -0.7476944905335507, -0.63110966324638, -0.5145248359592087, -0.3979400086720376];

/// [dimensionless] Log base-10 of root cutoff ratios, used to generate multi-stage filters
#[rustfmt::skip]
static LOG10_ROOT2_CUTOFF_RATIOS: [f64; 30] = [-3.9152572011733295, -3.7576198122368774, -3.641018296320703, -3.524433440525799, -3.4078485644151626, -3.291263653669992, -3.174678683533955, -3.058093611892881, -2.941508366607508, -2.8249228242514737, -2.7083367737080586, -2.5917498538487744, -2.4751614468989587, -2.3585704961455844, -2.2419751941385835, -2.1253724496553015, -2.008756976792869, -1.8921197394831588, -1.7754452987293663, -1.6587072985249718, -1.5418608139628553, -1.424829467665756, -1.3074839973806804, -1.189607382280121, -1.0708404623027254, -0.9506043276547652, -0.8280110761213737, -0.7018244165495513, -0.5707375866790332, -0.438004836846182];

/// State-Space `D` 1x1 matrix
#[rustfmt::skip]
static DVALS: [f64; 30] = [2.7301014891290886e-07, 4.6692770859195915e-07, 7.985279112723217e-07, 1.3654971837121069e-06, 2.3347455647959314e-06, 3.991355393650326e-06, 6.822012312625801e-06, 1.1657050264703937e-05, 1.991193416409801e-05, 3.399700190274455e-05, 5.801095637244669e-05, 9.891074446252507e-05, 0.0001684765733075827, 0.0002865938975023847, 0.0004866945965911907, 0.0008246908187259839, 0.0013934583868314275, 0.0023459304232689706, 0.003931130865975085, 0.0065488413459389, 0.010829611409785306, 0.017746771669981412, 0.028765536734274576, 0.04603312308398933, 0.07262300813136068, 0.11289640475605454, 0.17321395893100267, 0.26374066641385013, 0.403719642760601, 0.6389455251590223];

/// State-Space `A` matrix, first row
#[rustfmt::skip]
static AVALS: [[f64; 30]; 2] = [[1.9985215903550178, 1.99806634247146, 1.997470909968996, 1.996692126041801, 1.9956735319580101, 1.9943412846441892, 1.99259880480184, 1.990319778601047, 1.9873390079063333, 1.9834404508227914, 1.9783415968378355, 1.9716730686360946, 1.962952026041677, 1.9515475616284588, 1.9366358319512198, 1.9171422069138446, 1.8916673576399918, 1.858394188703011, 1.8149733181147387, 1.7583871504687762, 1.6847973062172095, 1.5893872999364358, 1.4662184992773086, 1.308109787164757, 1.1064975705935658, 0.8510664399947364, 0.5285390296573945, 0.11911969612602526, -0.4129918204081231, -1.1429805025399007], [-0.9985226823956134, -0.9980682101822944, -0.9974741040806411, -0.9966975880305358, -0.9956828709402693, -0.9943572500657639, -0.9926260928510905, -0.9903664068021057, -0.9874186556429897, -0.9835764388304024, -0.9785736406633253, -0.9720687116139447, -0.9636259323349073, -0.9526939372184684, -0.9385826103375845, -0.9204409701887486, -0.8972411911873176, -0.867777910396087, -0.830697841578639, -0.7845825158525318, -0.7281157518563508, -0.6603743866163615, -0.581280646214407, -0.4922422795007142, -0.39698960311900844, -0.3026520590189545, -0.22139486538140507, -0.17408236178142591, -0.20188675063428063, -0.41280159809618844]];

/// State-Space `C` vector
#[rustfmt::skip]
static CVALS: [[f64; 30]; 2] = [[1.0916369748143046e-06, 1.8668079560888338e-06, 3.1920920961094096e-06, 5.457471842274432e-06, 9.328881057111458e-06, 1.5942835630544758e-05, 2.723755820573321e-05, 4.651535823139469e-05, 7.939563181537078e-05, 0.00013542503258609205, 0.00023078740080884958, 0.00039284113998055753, 0.0006676645775298439, 0.0011324894168531449, 0.0019159393881579253, 0.003230431213685886, 0.005422876518261547, 0.009051524312242591, 0.014997159363712235, 0.024613081165035404, 0.039904922950156047, 0.06370003684710301, 0.09970763556998352, 0.15228262500790501, 0.22560319832926873, 0.3218751507960492, 0.4379782556385133, 0.5588980408669935, 0.6407063753229842, 0.5475887728761645], [4.0332269916525135e-10, 9.020061930625643e-10, 2.016998392576984e-09, 4.509434243760667e-09, 1.007939792485773e-08, 2.2522220385033145e-08, 5.0304885362020193e-08, 1.1229928013756292e-07, 2.505189005326354e-07, 5.583518403326496e-07, 1.2429635967002e-06, 2.7627045280622037e-06, 6.128178277472964e-06, 1.3557628908051646e-05, 2.989151168543327e-05, 6.561160143208592e-05, 0.0001431901239608395, 0.0003101838226300152, 0.000665548940646416, 0.001410734926823077, 0.002944400755837363, 0.006027258213996816, 0.012044686952671187, 0.023373673644589477, 0.04379242895598327, 0.07872807540079735, 0.1348652778112931, 0.2178280683067199, 0.3222139959164307, 0.3751877912769695]];

#[cfg(feature = "std")]
#[cfg(test)]
#[rustfmt::skip]
mod test {
    use super::*;
    static CUTOFF_TEST_INPUT: [f32; 101] = [0.0, 0.5877852522924732, -0.9510565162951536, 0.9510565162951535, -0.5877852522924728, -4.898587196589413e-16, 0.5877852522924736, -0.9510565162951538, 0.9510565162951533, -0.5877852522924725, -9.797174393178826e-16, 0.587785252292474, -0.951056516295154, 0.9510565162951532, -0.587785252292472, -1.4695761589768238e-15, 0.5877852522924744, -0.9510565162951541, 0.951056516295153, -0.5877852522924716, -1.959434878635765e-15, 0.5877852522924748, -0.9510565162951542, 0.9510565162951529, -0.5877852522924712, -2.4492935982947065e-15, 0.5877852522924751, -0.9510565162951544, 0.9510565162951528, -0.5877852522924708, -2.9391523179536475e-15, 0.5877852522924756, -0.9510565162951545, 0.9510565162951525, -0.5877852522924705, -3.429011037612589e-15, 0.587785252292476, -0.9510565162951546, 0.9510565162951524, -0.58778525229247, -3.91886975727153e-15, 0.5877852522924764, -0.9510565162951549, 0.9510565162951523, -0.5877852522924697, -4.408728476930472e-15, 0.5877852522924768, -0.951056516295155, 0.9510565162951521, -0.5877852522924693, -4.898587196589413e-15, 0.5877852522924887, -0.9510565162951552, 0.9510565162951563, -0.5877852522924688, -1.9599300631450357e-14, 0.5877852522924776, -0.9510565162951509, 0.9510565162951519, -0.5877852522924569, -5.878304635907295e-15, 0.5877852522924665, -0.9510565162951554, 0.9510565162951473, -0.587785252292468, 7.842691359635767e-15, 0.5877852522924784, -0.95105651629516, 0.9510565162951515, -0.5877852522924791, -6.858022075225178e-15, 0.5877852522924902, -0.9510565162951558, 0.9510565162951558, -0.5877852522924673, -2.1558735510086122e-14, 0.5877852522924791, -0.9510565162951515, 0.9510565162951512, -0.5877852522924554, -7.83773951454306e-15, 0.587785252292468, -0.9510565162951561, 0.9510565162951466, -0.5877852522924665, 5.883256481000002e-15, 0.5877852522924799, -0.9510565162951606, 0.9510565162951509, -0.5877852522924776, -8.817456953860943e-15, 0.5877852522924918, -0.9510565162951563, 0.9510565162951552, -0.5877852522924657, -2.3518170388721888e-14, 0.5877852522924807, -0.9510565162951521, 0.9510565162951506, -0.5877852522924538, -9.797174393178826e-15];
    static CUTOFF_TEST_OUTPUT: [f32; 101] = [0.0, 0.3755627567067427, -0.28580870024257504, -0.06046968287379362, 0.41920850528282105, -0.597637374463856, 0.5100379256850617, -0.19280553319986204, -0.2222820541365811, 0.5657650347226962, -0.6983522246845354, 0.5646542662393133, -0.21365569445033594, -0.2209964390154373, 0.5729025815902173, -0.7070410055666212, 0.5716389826249799, -0.218052346461291, -0.21885445357671462, 0.5722692789734278, -0.707201368035627, 0.5720837021326813, -0.21849445430421283, -0.21853271385571893, 0.5720840395695259, -0.7071224576796631, 0.5720699762563267, -0.2185113402162075, -0.21850774752384694, 0.572062474070433, -0.7071081148763674, 0.5720624849842976, -0.2185086985704603, -0.21850767446436525, 0.5720613000892838, -0.7071068031978743, 0.5720614703826485, -0.2185080803635357, -0.21850796223364444, 0.5720613738071527, -0.7071067686643426, 0.572061400480641, -0.21850801472240117, -0.21850800840452111, 0.5720613994827992, -0.7071067789516946, 0.5720614016399355, -0.21850801180081653, -0.2185080122223938, 0.5720614026405184, -0.7071067809848819, 0.5720614026603249, -0.21850801212778392, -0.2185080122698848, 0.5720614028297781, -0.7071067811816037, 0.5720614028070218, -0.2185080122142693, -0.21850801223159488, 0.5720614028217192, -0.7071067811881777, 0.5720614028178805, -0.21850801222397526, -0.2185080122249995, 0.5720614028181716, -0.707106781186854, 0.5720614028178498, -0.21850801222446548, -0.21850801222442195, 0.5720614028177091, -0.7071067811865845, 0.5720614028177146, -0.21850801222441385, -0.21850801222440963, 0.5720614028176896, -0.7071067811865587, 0.5720614028176747, -0.21850801222439975, -0.21850801222441385, 0.5720614028176931, -0.7071067811865398, 0.5720614028176698, -0.21850801222441035, -0.21850801222441552, 0.5720614028176834, -0.7071067811865365, 0.572061402817688, -0.21850801222441152, -0.21850801222441718, 0.5720614028176814, -0.7071067811865545, 0.5720614028176908, -0.21850801222439886, -0.21850801222441707, 0.5720614028176918, -0.7071067811865578, 0.5720614028176725, -0.21850801222439714, -0.21850801222441607, 0.5720614028176945, -0.70710678118654];
    const STEP_TEST_MIN_OUTPUT: f32 = 1.0000000000304905;
    const STEP_TEST_MAX_OUTPUT: f32 = 0.9999198923630226;

    #[test]
    fn test() {
        let order = 2;
        println!("order {order}");
        let mut filter = butter2(0.4).unwrap();
        let out = (0..CUTOFF_TEST_INPUT.len()).map(|i| {filter.update(CUTOFF_TEST_INPUT[i])}).collect::<Vec<f32>>();

        // Check overall match to reference output to catch phase error, etc
        (0..CUTOFF_TEST_INPUT.len()).for_each(|i| { let expected = CUTOFF_TEST_OUTPUT[i]; let rel_err = (out[i] - expected).abs() / expected.abs().max(1e-4); assert!(rel_err < 0.05); });
        // Check approximate attenuation at cutoff frequency; should be -3dB or 1/sqrt(2) magnitude
        let maxmag = out.iter().fold(0.0_f32, |a, b| a.abs().max(b.abs()));
        let attenuation_rel_err = (maxmag - (libm::sqrtf(2.0) / 2.0)).abs() / (libm::sqrtf(2.0) / 2.0);
        println!("order {order} attenuation rel err {attenuation_rel_err}");
        assert!(attenuation_rel_err < 0.05);

        // Check convergence of step responses at min and max tabulated cutoff
        let mut filtermin = butter2(MIN_CUTOFF_RATIO).unwrap();
        (0..60099).for_each(|_| {filtermin.update(1.0);});
        let step_min_final = filtermin.update(1.0);
        let step_min_rel_err = (step_min_final - STEP_TEST_MIN_OUTPUT).abs() / STEP_TEST_MIN_OUTPUT;
        println!("order {order} step min rel err {step_min_rel_err}");
        assert!(step_min_rel_err < 1e-4);


    // Check response of staged filter
    let freq = 0.17;
    let mut filter_2stage = butter2_2stage(freq).unwrap();
    let mut maxmag_2stage = 0.0;
    for i in 0..99999 {
        let u = libm::sin((i as f64) * 2.0 * core::f64::consts::PI * freq) as f32;
        let v = filter_2stage.update(u);
        maxmag_2stage = v.abs().max(maxmag_2stage);
    }
    let attenuation_2stage_rel_err = (maxmag_2stage - (libm::sqrtf(2.0) / 2.0)).abs() / (libm::sqrtf(2.0) / 2.0);
    println!("order {order} attenuation 2stage rel err {attenuation_2stage_rel_err}");
    assert!(attenuation_2stage_rel_err < 0.05);

    let mut filtermin_2stage = butter2_2stage(MIN_CUTOFF_RATIO).unwrap();
    (0..99999).for_each(|_| {filtermin_2stage.update(1.0);});
    let step_min_2stage_final = filtermin_2stage.update(1.0);
    let step_min_2stage_rel_err = (step_min_2stage_final - STEP_TEST_MIN_OUTPUT).abs() / STEP_TEST_MIN_OUTPUT;
    println!("order {order} step min 2stage rel err {step_min_2stage_rel_err}");
    assert!(step_min_2stage_rel_err < 2e-4);  // 1e-4 per stage
    


                let mut filtermax = butter2(MAX_CUTOFF_RATIO).unwrap();
        (0..19).for_each(|_| {filtermax.update(1.0);});
        let step_max_final = filtermax.update(1.0);
        let step_max_rel_err = (step_max_final - STEP_TEST_MAX_OUTPUT).abs() / STEP_TEST_MAX_OUTPUT;
        println!("order {order} step max rel err {step_max_rel_err}");
        assert!(step_max_rel_err < 1e-6);
    }
}
