//! Butterworth filter of order 2.
//! Region of validity: cutoff ratio from 9.77e-04 to 4.00e-01 .
//! This file is autogenerated.
#![allow(clippy::style)]

use crate::{SisoIirFilter, StagedSisoIirFilter};

/// Minimum tabulated cutoff ratio
#[allow(dead_code)]
pub const MIN_CUTOFF_RATIO: f64 = 0.000977237220955811;

/// Maximum tabulated cutoff ratio
#[allow(dead_code)]
pub const MAX_CUTOFF_RATIO: f64 = 0.4;

/// Initialise a Butterworth filter of order 2 by interpolating the coefficients from stored tables.
/// Cutoff ratio is the dimensionless ratio of the cutoff frequency to the sampling frequency.
/// Region of validity: cutoff ratio from 9.77e-04 to 4.00e-01
pub fn butter2(cutoff_ratio: f64) -> Result<SisoIirFilter<2>, &'static str> {
    let avals = &[&AVALS[0][..], &AVALS[1][..]];
    let cvals = &[&CVALS[0][..], &CVALS[1][..]];
    SisoIirFilter::new_interpolated(cutoff_ratio, &LOG10_CUTOFF_RATIOS, avals, cvals, &DVALS)
}

/// Initialise a two-stage Butterworth filter of combined order 2*2 by interpolating the coefficients from stored tables.
/// Cutoff ratio is the dimensionless ratio of the cutoff frequency to the sampling frequency.
/// Region of validity: cutoff ratio from 7.28e-04 to 3.69e-01
pub fn butter2_2stage(cutoff_ratio: f64) -> Result<StagedSisoIirFilter<2, 2>, &'static str> {
    // Look up the per-stage cutoff ratio corresponding to the desired combined cutoff
    let log10_root_cutoff_ratio = libm::log10(cutoff_ratio);

    if log10_root_cutoff_ratio < LOG10_ROOT2_CUTOFF_RATIOS[0]
        || log10_root_cutoff_ratio > *LOG10_ROOT2_CUTOFF_RATIOS.last().ok_or("Table size error")?
    {
        return Err("Selected cutoff ratio is outside the grid");
    }

    let log10_cutoff_ratio = interpn::MulticubicRectilinear::<'_, _, 2>::new(
        &[&LOG10_ROOT2_CUTOFF_RATIOS],
        &LOG10_CUTOFF_RATIOS,
        true,
    )?
    .interp_one(&[log10_root_cutoff_ratio])?;
    let cutoff_ratio = libm::pow(10.0, log10_cutoff_ratio);
    let filt = butter2(cutoff_ratio)?;
    Ok(StagedSisoIirFilter::new([filt, filt]))
}

/// [dimensionless] Log base-10 of cutoff ratios, to improve float precision during interpolation
#[rustfmt::skip]
static LOG10_CUTOFF_RATIOS: [f64; 30] = [-3.01, -2.919928965816277, -2.8298579316325543, -2.7397868974488313, -2.6497158632651083, -2.5596448290813854, -2.469573794897663, -2.37950276071394, -2.289431726530217, -2.1993606923464943, -2.1092896581627714, -2.0192186239790484, -1.9291475897953259, -1.8390765556116029, -1.7490055214278801, -1.6589344872441572, -1.5688634530604344, -1.4787924188767116, -1.3887213846929887, -1.298650350509266, -1.208579316325543, -1.1185082821418202, -1.0284372479580974, -0.9383662137743745, -0.8482951795906519, -0.758224145406929, -0.668153111223206, -0.578082077039483, -0.48801104285576047, -0.3979400086720376];

/// [dimensionless] Log base-10 of root cutoff ratios, used to generate multi-stage filters
#[rustfmt::skip]
static LOG10_ROOT2_CUTOFF_RATIOS: [f64; 30] = [-3.1376155725271624, -3.0159467729122746, -2.925738568487123, -2.8356523559318285, -2.745580429771507, -2.6555080450894235, -2.565434966175013, -2.475360836157241, -2.3852851147129495, -2.2952069837680225, -2.205125204725173, -2.115037902304105, -2.0249422372909285, -1.9348339111072326, -1.8447064158229294, -1.7545498989350827, -1.6643494453436074, -1.5740824781951552, -1.4837148292381934, -1.3931948055294432, -1.3024442566732797, -1.2113452150657382, -1.1197202381850402, -1.0273071808985261, -0.9337507523914158, -0.8385585236852623, -0.7411036212786626, -0.6407000777222749, -0.536838700563364, -0.432574773421686];

/// State-Space `D` 1x1 matrix
#[rustfmt::skip]
static DVALS: [f64; 30] = [9.384623976803312e-06, 1.4194685455432101e-05, 2.1465214636748406e-05, 3.245058647634384e-05, 4.9041063043876834e-05, 7.40820706233679e-05, 0.00011185117313548968, 0.0001687684263863341, 0.00025445027393429715, 0.0003832657884767201, 0.0005766214157988958, 0.0008662913542700989, 0.0012992295437656693, 0.0019444473991765598, 0.0029027138974864375, 0.00432001450517496, 0.006405857686619371, 0.009457586334287171, 0.013891770684476402, 0.020283502238051903, 0.02941411378594663, 0.042328091546207265, 0.06040222174363995, 0.08543760653377828, 0.11980475757034816, 0.16671747813485047, 0.2308160750053737, 0.3194999780019074, 0.4461786533873034, 0.6389455251590223];

/// State-Space `A` matrix, first row
#[rustfmt::skip]
static AVALS: [[f64; 30]; 2] = [[1.9913165530586894, 1.9893153130690977, 1.9868528765748859, 1.9838229766934334, 1.9800948765944186, 1.975507748026711, 1.9698637694699697, 1.962919661403706, 1.9543763212557714, 1.9438661609469257, 1.9309376903410445, 1.9150368400297415, 1.8954844944457674, 1.8714497411361926, 1.841918480227301, 1.8056573432750698, 1.7611734146687203, 1.7066710760046826, 1.6400083306377504, 1.5586558304405411, 1.4596614922384494, 1.3396198700077875, 1.1946343391019993, 1.0202351072916762, 0.8111669385769612, 0.5608702598879285, 0.26031293797668803, -0.10449607685926844, -0.5576283550260307, -1.1429805025399007], [-0.9913540915545966, -0.9893720918109195, -0.9869387374334329, -0.9839527790393388, -0.9802910408465941, -0.9758040763092044, -0.9703111741625116, -0.9635947351092515, -0.9553941223515086, -0.9453992241008325, -0.93324417600424, -0.9185020054468219, -0.9006814126208301, -0.8792275307328987, -0.8535293358172467, -0.8229374012957696, -0.7867968454151978, -0.7445014213418314, -0.695575413375656, -0.6397898393927487, -0.5773179473822359, -0.5089322361926165, -0.4362432260765591, -0.36198553342678924, -0.290385968858354, -0.22774017242733038, -0.1835772379981828, -0.1735038351483613, -0.22708625852318237, -0.41280159809618844]];

/// State-Space `C` vector
#[rustfmt::skip]
static CVALS: [[f64; 30]; 2] = [[3.745700502284652e-05, 5.6627076051554484e-05, 8.557865272081773e-05, 0.0001292773920116358, 0.00019518808376367807, 0.00029451384575306105, 0.00044403391980329325, 0.0006688157151505675, 0.0010061921381828293, 0.0015115489738219785, 0.0022666628564216944, 0.0033915625661666933, 0.005061128542465014, 0.007527830380195035, 0.01115199016556576, 0.016440494924673903, 0.024093541629064047, 0.03505616171411941, 0.05056616101880339, 0.07218200350119716, 0.10176287679355966, 0.14135973558722242, 0.19296301174028563, 0.25804165873628987, 0.33679117356599064, 0.4269418315590545, 0.5217165606276438, 0.6056134617459928, 0.6435554382385152, 0.5475887728761645], [8.113859969797876e-08, 1.5085981379320943e-07, 2.8036280441829034e-07, 5.207417314889343e-07, 9.665483083713734e-07, 1.792484127659144e-06, 3.320729998938321e-06, 6.144059267789272e-06, 1.1349977786738393e-05, 2.0926609426435093e-05, 3.849283774525706e-05, 7.060100807176981e-05, 0.0001290376429680896, 0.00023483571375854605, 0.00042516243249734716, 0.000764912994726248, 0.0013657490666085532, 0.002416399865947291, 0.00422899654810191, 0.007306323598846217, 0.012432817990976393, 0.020785961261830216, 0.034052161668002776, 0.05451042895794042, 0.08501513696944238, 0.12874921091776995, 0.1884434974703058, 0.26406550648875937, 0.34485761235666884, 0.3751877912769695]];

#[cfg(feature = "std")]
#[cfg(test)]
#[rustfmt::skip]
mod test {
    use super::*;
    static CUTOFF_TEST_INPUT: [f32; 101] = [0.0, 0.5877852522924732, -0.9510565162951536, 0.9510565162951535, -0.5877852522924728, -4.898587196589413e-16, 0.5877852522924736, -0.9510565162951538, 0.9510565162951533, -0.5877852522924725, -9.797174393178826e-16, 0.587785252292474, -0.951056516295154, 0.9510565162951532, -0.587785252292472, -1.4695761589768238e-15, 0.5877852522924744, -0.9510565162951541, 0.951056516295153, -0.5877852522924716, -1.959434878635765e-15, 0.5877852522924748, -0.9510565162951542, 0.9510565162951529, -0.5877852522924712, -2.4492935982947065e-15, 0.5877852522924751, -0.9510565162951544, 0.9510565162951528, -0.5877852522924708, -2.9391523179536475e-15, 0.5877852522924756, -0.9510565162951545, 0.9510565162951525, -0.5877852522924705, -3.429011037612589e-15, 0.587785252292476, -0.9510565162951546, 0.9510565162951524, -0.58778525229247, -3.91886975727153e-15, 0.5877852522924764, -0.9510565162951549, 0.9510565162951523, -0.5877852522924697, -4.408728476930472e-15, 0.5877852522924768, -0.951056516295155, 0.9510565162951521, -0.5877852522924693, -4.898587196589413e-15, 0.5877852522924887, -0.9510565162951552, 0.9510565162951563, -0.5877852522924688, -1.9599300631450357e-14, 0.5877852522924776, -0.9510565162951509, 0.9510565162951519, -0.5877852522924569, -5.878304635907295e-15, 0.5877852522924665, -0.9510565162951554, 0.9510565162951473, -0.587785252292468, 7.842691359635767e-15, 0.5877852522924784, -0.95105651629516, 0.9510565162951515, -0.5877852522924791, -6.858022075225178e-15, 0.5877852522924902, -0.9510565162951558, 0.9510565162951558, -0.5877852522924673, -2.1558735510086122e-14, 0.5877852522924791, -0.9510565162951515, 0.9510565162951512, -0.5877852522924554, -7.83773951454306e-15, 0.587785252292468, -0.9510565162951561, 0.9510565162951466, -0.5877852522924665, 5.883256481000002e-15, 0.5877852522924799, -0.9510565162951606, 0.9510565162951509, -0.5877852522924776, -8.817456953860943e-15, 0.5877852522924918, -0.9510565162951563, 0.9510565162951552, -0.5877852522924657, -2.3518170388721888e-14, 0.5877852522924807, -0.9510565162951521, 0.9510565162951506, -0.5877852522924538, -9.797174393178826e-15];
    static CUTOFF_TEST_OUTPUT: [f32; 101] = [0.0, 0.3755627567067427, -0.28580870024257504, -0.06046968287379362, 0.41920850528282105, -0.597637374463856, 0.5100379256850617, -0.19280553319986204, -0.2222820541365811, 0.5657650347226962, -0.6983522246845354, 0.5646542662393133, -0.21365569445033594, -0.2209964390154373, 0.5729025815902173, -0.7070410055666212, 0.5716389826249799, -0.218052346461291, -0.21885445357671462, 0.5722692789734278, -0.707201368035627, 0.5720837021326813, -0.21849445430421283, -0.21853271385571893, 0.5720840395695259, -0.7071224576796631, 0.5720699762563267, -0.2185113402162075, -0.21850774752384694, 0.572062474070433, -0.7071081148763674, 0.5720624849842976, -0.2185086985704603, -0.21850767446436525, 0.5720613000892838, -0.7071068031978743, 0.5720614703826485, -0.2185080803635357, -0.21850796223364444, 0.5720613738071527, -0.7071067686643426, 0.572061400480641, -0.21850801472240117, -0.21850800840452111, 0.5720613994827992, -0.7071067789516946, 0.5720614016399355, -0.21850801180081653, -0.2185080122223938, 0.5720614026405184, -0.7071067809848819, 0.5720614026603249, -0.21850801212778392, -0.2185080122698848, 0.5720614028297781, -0.7071067811816037, 0.5720614028070218, -0.2185080122142693, -0.21850801223159488, 0.5720614028217192, -0.7071067811881777, 0.5720614028178805, -0.21850801222397526, -0.2185080122249995, 0.5720614028181716, -0.707106781186854, 0.5720614028178498, -0.21850801222446548, -0.21850801222442195, 0.5720614028177091, -0.7071067811865845, 0.5720614028177146, -0.21850801222441385, -0.21850801222440963, 0.5720614028176896, -0.7071067811865587, 0.5720614028176747, -0.21850801222439975, -0.21850801222441385, 0.5720614028176931, -0.7071067811865398, 0.5720614028176698, -0.21850801222441035, -0.21850801222441552, 0.5720614028176834, -0.7071067811865365, 0.572061402817688, -0.21850801222441152, -0.21850801222441718, 0.5720614028176814, -0.7071067811865545, 0.5720614028176908, -0.21850801222439886, -0.21850801222441707, 0.5720614028176918, -0.7071067811865578, 0.5720614028176725, -0.21850801222439714, -0.21850801222441607, 0.5720614028176945, -0.70710678118654];
    const STEP_TEST_MIN_OUTPUT: f32 = 0.9999999999986624;
    const STEP_TEST_MAX_OUTPUT: f32 = 0.9999198923630226;

    #[test]
    fn test() {
        let order = 2;
        println!("order {order}");
        let mut filter = butter2(0.4).unwrap();
        let out = (0..CUTOFF_TEST_INPUT.len()).map(|i| {filter.update(CUTOFF_TEST_INPUT[i])}).collect::<Vec<f32>>();

        // Check overall match to reference output to catch phase error, etc
        (0..CUTOFF_TEST_INPUT.len()).for_each(|i| { let expected = CUTOFF_TEST_OUTPUT[i]; let rel_err = (out[i] - expected).abs() / expected.abs().max(1e-4); assert!(rel_err < 0.05); });
        // Check approximate attenuation at cutoff frequency; should be -3dB or 1/sqrt(2) magnitude
        let maxmag = out.iter().fold(0.0_f32, |a, b| a.abs().max(b.abs()));
        let attenuation_rel_err = (maxmag - (libm::sqrtf(2.0) / 2.0)).abs() / (libm::sqrtf(2.0) / 2.0);
        println!("order {order} attenuation rel err {attenuation_rel_err}");
        assert!(attenuation_rel_err < 0.05);

        // Check convergence of step responses at min and max tabulated cutoff
        let mut filtermin = butter2(MIN_CUTOFF_RATIO).unwrap();
        (0..10229).for_each(|_| {filtermin.update(1.0);});
        let step_min_final = filtermin.update(1.0);
        let step_min_rel_err = (step_min_final - STEP_TEST_MIN_OUTPUT).abs() / STEP_TEST_MIN_OUTPUT;
        println!("order {order} step min rel err {step_min_rel_err}");
        assert!(step_min_rel_err < 1e-4);


    // Check response of staged filter
    let freq = 0.17;
    let mut filter_2stage = butter2_2stage(freq).unwrap();
    let mut maxmag_2stage = 0.0;
    for i in 0..99999 {
        let u = libm::sin((i as f64) * 2.0 * core::f64::consts::PI * freq) as f32;
        let v = filter_2stage.update(u);
        maxmag_2stage = v.abs().max(maxmag_2stage);
    }
    let attenuation_2stage_rel_err = (maxmag_2stage - (libm::sqrtf(2.0) / 2.0)).abs() / (libm::sqrtf(2.0) / 2.0);
    println!("order {order} attenuation 2stage rel err {attenuation_2stage_rel_err}");
    assert!(attenuation_2stage_rel_err < 0.05);

    let mut filtermin_2stage = butter2_2stage(MIN_CUTOFF_RATIO).unwrap();
    (0..99999).for_each(|_| {filtermin_2stage.update(1.0);});
    let step_min_2stage_final = filtermin_2stage.update(1.0);
    let step_min_2stage_rel_err = (step_min_2stage_final - STEP_TEST_MIN_OUTPUT).abs() / STEP_TEST_MIN_OUTPUT;
    println!("order {order} step min 2stage rel err {step_min_2stage_rel_err}");
    assert!(step_min_2stage_rel_err < 2e-4);  // 1e-4 per stage
    


                let mut filtermax = butter2(MAX_CUTOFF_RATIO).unwrap();
        (0..19).for_each(|_| {filtermax.update(1.0);});
        let step_max_final = filtermax.update(1.0);
        let step_max_rel_err = (step_max_final - STEP_TEST_MAX_OUTPUT).abs() / STEP_TEST_MAX_OUTPUT;
        println!("order {order} step max rel err {step_max_rel_err}");
        assert!(step_max_rel_err < 1e-6);
    }
}
