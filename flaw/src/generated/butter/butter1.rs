//! Butterworth filter of order 1.
//! Region of validity: cutoff ratio from 1.00e-04 to 4.00e-01 .
//! This file is autogenerated.
#![allow(clippy::style)]

use crate::{SisoIirFilter, StagedSisoIirFilter};

/// Minimum tabulated cutoff ratio
#[allow(dead_code)]
pub const MIN_CUTOFF_RATIO: f64 = 0.0001;

/// Maximum tabulated cutoff ratio
#[allow(dead_code)]
pub const MAX_CUTOFF_RATIO: f64 = 0.4;

/// Initialise a Butterworth filter of order 1 by interpolating the coefficients from stored tables.
/// Cutoff ratio is the dimensionless ratio of the cutoff frequency to the sampling frequency.
/// Region of validity: cutoff ratio from 1.00e-04 to 4.00e-01
pub fn butter1(cutoff_ratio: f64) -> Result<SisoIirFilter<1>, &'static str> {
    let avals = &[&AVALS[0][..]];
    let cvals = &[&CVALS[0][..]];
    SisoIirFilter::new_interpolated(cutoff_ratio, &LOG10_CUTOFF_RATIOS, avals, cvals, &DVALS)
}

/// Initialise a two-stage Butterworth filter of combined order 2*1 by interpolating the coefficients from stored tables.
/// Cutoff ratio is the dimensionless ratio of the cutoff frequency to the sampling frequency.
/// Region of validity: cutoff ratio from 5.74e-05 to 3.50e-01
pub fn butter1_2stage(cutoff_ratio: f64) -> Result<StagedSisoIirFilter<1, 2>, &'static str> {
    // Look up the per-stage cutoff ratio corresponding to the desired combined cutoff
    let log10_root_cutoff_ratio = libm::log10(cutoff_ratio);

    if log10_root_cutoff_ratio < LOG10_ROOT2_CUTOFF_RATIOS[0]
        || log10_root_cutoff_ratio > *LOG10_ROOT2_CUTOFF_RATIOS.last().ok_or("Table size error")?
    {
        return Err("Selected cutoff ratio is outside the grid");
    }

    let log10_cutoff_ratio = interpn::MulticubicRectilinear::<'_, _, 1>::new(
        &[&LOG10_ROOT2_CUTOFF_RATIOS],
        &LOG10_CUTOFF_RATIOS,
        true,
    )?
    .interp_one(&[log10_root_cutoff_ratio])?;
    let cutoff_ratio = libm::pow(10.0, log10_cutoff_ratio);
    let filt = butter1(cutoff_ratio)?;
    Ok(StagedSisoIirFilter::new([filt, filt]))
}

/// [dimensionless] Log base-10 of cutoff ratios, to improve float precision during interpolation
#[rustfmt::skip]
static LOG10_CUTOFF_RATIOS: [f64; 50] = [-4.0, -3.9264885716055518, -3.8529771432111035, -3.7794657148166553, -3.705954286422207, -3.632442858027759, -3.5589314296333106, -3.4854200012388628, -3.411908572844414, -3.3383971444499663, -3.2648857160555176, -3.19137428766107, -3.1178628592666215, -3.0443514308721733, -2.970840002477725, -2.897328574083277, -2.8238171456888286, -2.7503057172943803, -2.676794288899932, -2.603282860505484, -2.5297714321110356, -2.4562600037165874, -2.3827485753221396, -2.309237146927691, -2.235725718533243, -2.1622142901387944, -2.0887028617443466, -2.015191433349898, -1.9416800049554501, -1.8681685765610019, -1.7946571481665536, -1.7211457197721054, -1.6476342913776572, -1.574122862983209, -1.5006114345887607, -1.4271000061943124, -1.3535885777998642, -1.280077149405416, -1.2065657210109677, -1.1330542926165195, -1.0595428642220712, -0.9860314358276234, -0.9125200074331752, -0.8390085790387269, -0.7654971506442787, -0.6919857222498305, -0.6184742938553822, -0.544962865460934, -0.47145143706648573, -0.3979400086720376];

/// [dimensionless] Log base-10 of root cutoff ratios, used to generate multi-stage filters
#[rustfmt::skip]
static LOG10_ROOT2_CUTOFF_RATIOS: [f64; 50] = [-4.241309851961088, -4.138831749184097, -4.048642023537363, -3.9703755900134174, -3.897313399683558, -3.8238019582688354, -3.7502905116082177, -3.676779057588551, -3.6032675932447416, -3.5297561144172622, -3.4562446152708377, -3.3827330876196267, -3.3092215199788955, -3.2357098962375987, -3.1621981937933246, -3.088686380937777, -3.015174413187239, -2.941662228136364, -2.8681497382369416, -2.7946368206681704, -2.7211233031253665, -2.6476089438823225, -2.574093403820284, -2.5005762071859503, -2.4270566865353795, -2.353533905489135, -2.2800065503519247, -2.206472778038391, -2.1329300026735414, -2.0593745961059797, -1.9858014675425026, -1.9122034733912796, -1.8385705884883101, -1.7648887417464265, -1.6911381793993143, -1.617291162300463, -1.5433087226204734, -1.4691360883941165, -1.394696214200651, -1.31988060514087, -1.2445362441326333, -1.1684468544155944, -1.091305828397202, -1.012676778664119, -0.9319359962498311, -0.84819256426012, -0.7602186108778677, -0.6664645502696814, -0.5647192421425198, -0.4560070219279612];

/// State-Space `D` 1x1 matrix
#[rustfmt::skip]
static DVALS: [f64; 50] = [0.0003140606106404424, 0.0003719630067003384, 0.0004405359887902795, 0.0005217441011352636, 0.0006179128154659001, 0.0007317945345893107, 0.0008666465429917472, 0.0010263230173686764, 0.0012153835636073901, 0.0014392211513462568, 0.0017042127766443516, 0.0020178966999427504, 0.00238918068036118, 0.0028285862544819005, 0.0033485347781058443, 0.003963681644027055, 0.004691305775714011, 0.005551762125712215, 0.006569005403241123, 0.007771193508622324, 0.009191379009141496, 0.010868296241381753, 0.012847249989338226, 0.015181108805917623, 0.01793140147304715, 0.021169508312204183, 0.02497792950244807, 0.029451599718587657, 0.03469920194754486, 0.040844413422566436, 0.04802699427358451, 0.05640360729943455, 0.06614824020726519, 0.07745209825651742, 0.09052285884405027, 0.10558324966913951, 0.12286905545239299, 0.14262690951580898, 0.16511262978789484, 0.1905914710947789, 0.21934257128627344, 0.25167122036580136, 0.28793470643944064, 0.32859115410384343, 0.3742878232928131, 0.42602043740058465, 0.4854306701878709, 0.5554011821794174, 0.6413768790050783, 0.7547627247472144];

/// State-Space `A` matrix, first row
#[rustfmt::skip]
static AVALS: [[f64; 50]; 1] = [[0.9993718787787192, 0.9992560739865992, 0.9991189280224194, 0.9989565117977295, 0.9987641743690683, 0.9985364109308213, 0.9982667069140166, 0.9979473539652627, 0.9975692328727852, 0.9971215576973074, 0.9965915744467114, 0.9959642066001144, 0.9952216386392776, 0.9943428274910361, 0.9933029304437884, 0.9920726367119457, 0.9906173884485721, 0.9888964757485756, 0.9868619891935176, 0.9844576129827555, 0.9816172419817172, 0.9782634075172365, 0.9743055000213235, 0.9696377823881649, 0.9641371970539055, 0.9576609833755916, 0.9500441409951039, 0.9410968005628246, 0.9306015961049103, 0.9183111731548672, 0.903946011452831, 0.8871927854011308, 0.8677035195854695, 0.8450958034869651, 0.8189542823118994, 0.788833500661721, 0.7542618890952141, 0.7147461809683822, 0.6697747404242101, 0.6188170578104422, 0.5613148574274534, 0.4966575592683972, 0.4241305871211188, 0.3428176917923133, 0.2514243534143738, 0.14795912519883062, 0.02913865962425833, -0.11080236435883467, -0.2827537580101565, -0.5095254494944288]];

/// State-Space `C` vector
#[rustfmt::skip]
static CVALS: [[f64; 50]; 1] = [[0.0006279239531465732, 0.0007436493004439697, 0.0008806838336657202, 0.001042943768456388, 0.0012350619984367662, 0.0014625180226969117, 0.0017317909335225353, 0.002050539356865391, 0.0024278128128014066, 0.0028742995876475485, 0.0034026168709125476, 0.0040276495857022206, 0.0047669449920755376, 0.005641170708565712, 0.00667464418589132, 0.007895941743703715, 0.009338594851665528, 0.011041880126023446, 0.013051707142506624, 0.015421604120147741, 0.01821379512210362, 0.021500352756382637, 0.025364396314099348, 0.029901285482681027, 0.0352197326285191, 0.041442720460047405, 0.04870806508043761, 0.05716840598520749, 0.06699033466349671, 0.07835229462946583, 0.09144080418925919, 0.10644448076609143, 0.12354530104949427, 0.14290654146436038, 0.16465694174150083, 0.1888708541168873, 0.21554450132925954, 0.24456894839555643, 0.2757008985448408, 0.3085327244814139, 0.34246281541559903, 0.3766656344107792, 0.41005662253414754, 0.44123801509709537, 0.46839289725508204, 0.4890540486351983, 0.4995754692576509, 0.49386141802624606, 0.460025156165567, 0.37019190815875014]];

#[cfg(feature = "std")]
#[cfg(test)]
#[rustfmt::skip]
mod test {
    use super::*;
    static CUTOFF_TEST_INPUT: [f32; 101] = [0.0, 0.5877852522924732, -0.9510565162951536, 0.9510565162951535, -0.5877852522924728, -4.898587196589413e-16, 0.5877852522924736, -0.9510565162951538, 0.9510565162951533, -0.5877852522924725, -9.797174393178826e-16, 0.587785252292474, -0.951056516295154, 0.9510565162951532, -0.587785252292472, -1.4695761589768238e-15, 0.5877852522924744, -0.9510565162951541, 0.951056516295153, -0.5877852522924716, -1.959434878635765e-15, 0.5877852522924748, -0.9510565162951542, 0.9510565162951529, -0.5877852522924712, -2.4492935982947065e-15, 0.5877852522924751, -0.9510565162951544, 0.9510565162951528, -0.5877852522924708, -2.9391523179536475e-15, 0.5877852522924756, -0.9510565162951545, 0.9510565162951525, -0.5877852522924705, -3.429011037612589e-15, 0.587785252292476, -0.9510565162951546, 0.9510565162951524, -0.58778525229247, -3.91886975727153e-15, 0.5877852522924764, -0.9510565162951549, 0.9510565162951523, -0.5877852522924697, -4.408728476930472e-15, 0.5877852522924768, -0.951056516295155, 0.9510565162951521, -0.5877852522924693, -4.898587196589413e-15, 0.5877852522924887, -0.9510565162951552, 0.9510565162951563, -0.5877852522924688, -1.9599300631450357e-14, 0.5877852522924776, -0.9510565162951509, 0.9510565162951519, -0.5877852522924569, -5.878304635907295e-15, 0.5877852522924665, -0.9510565162951554, 0.9510565162951473, -0.587785252292468, 7.842691359635767e-15, 0.5877852522924784, -0.95105651629516, 0.9510565162951515, -0.5877852522924791, -6.858022075225178e-15, 0.5877852522924902, -0.9510565162951558, 0.9510565162951558, -0.5877852522924673, -2.1558735510086122e-14, 0.5877852522924791, -0.9510565162951515, 0.9510565162951512, -0.5877852522924554, -7.83773951454306e-15, 0.587785252292468, -0.9510565162951561, 0.9510565162951466, -0.5877852522924665, 5.883256481000002e-15, 0.5877852522924799, -0.9510565162951606, 0.9510565162951509, -0.5877852522924776, -8.817456953860943e-15, 0.5877852522924918, -0.9510565162951563, 0.9510565162951552, -0.5877852522924657, -2.3518170388721888e-14, 0.5877852522924807, -0.9510565162951521, 0.9510565162951506, -0.5877852522924538, -9.797174393178826e-15];
    static CUTOFF_TEST_OUTPUT: [f32; 101] = [0.0, 0.44363839858649595, -0.5002286634938007, 0.25487923461667605, 0.14431615245617008, -0.5171711510360325, 0.7071502617836815, -0.6344946640364608, 0.323291178894994, 0.1094585257969724, -0.49941030314419593, 0.6981006577781912, -0.6298836604878166, 0.3209417552392504, 0.11065561694121828, -0.5000202515475538, 0.6984114420125804, -0.6300420129645394, 0.3210224398561308, 0.11061450607553514, -0.4999993045152374, 0.6984007689665237, -0.6300365747759498, 0.3210196689606451, 0.1106159179173033, -0.5000000238845491, 0.6984011355034956, -0.6300367615358649, 0.3210197641195746, 0.11061586943140711, -0.49999999917975113, 0.6984011229157723, -0.6300367551220993, 0.32101976085159745, 0.11061587109652476, -0.500000000028171, 0.6984011233480638, -0.6300367553423626, 0.3210197609638271, 0.11061587103934117, -0.49999999999903455, 0.6984011233332178, -0.6300367553347981, 0.3210197609599726, 0.11061587104130527, -0.5000000000000354, 0.6984011233337277, -0.6300367553350577, 0.32101976096010454, 0.1106158710412381, -0.5000000000000013, 0.6984011233337191, -0.6300367553350443, 0.32101976096010076, 0.11061587104124365, -0.5000000000000149, 0.6984011233337064, -0.6300367553350431, 0.3210197609601001, 0.11061587104124965, -0.4999999999999985, 0.6984011233337, -0.6300367553350517, 0.32101976096009754, 0.11061587104123904, -0.49999999999999123, 0.6984011233337157, -0.6300367553350541, 0.32101976096009865, 0.11061587104123344, -0.5000000000000079, 0.698401123333722, -0.6300367553350451, 0.3210197609601003, 0.1106158710412446, -0.5000000000000157, 0.6984011233337064, -0.6300367553350426, 0.3210197609600987, 0.11061587104125092, -0.4999999999999995, 0.6984011233337002, -0.6300367553350512, 0.32101976096009627, 0.11061587104124032, -0.4999999999999922, 0.6984011233337158, -0.6300367553350534, 0.32101976096009727, 0.11061587104123471, -0.5000000000000088, 0.6984011233337222, -0.6300367553350446, 0.32101976096009915, 0.11061587104124593, -0.5000000000000165, 0.6984011233337066, -0.6300367553350418, 0.32101976096009766, 0.11061587104125231, -0.5000000000000006];
    const STEP_TEST_MIN_OUTPUT: f32 = 1.0000000000000966;
    const STEP_TEST_MAX_OUTPUT: f32 = 1.1249546329059645;

    #[test]
    fn test() {
        let order = 1;
        println!("order {order}");
        let mut filter = butter1(0.4).unwrap();
        let out = (0..CUTOFF_TEST_INPUT.len()).map(|i| {filter.update(CUTOFF_TEST_INPUT[i])}).collect::<Vec<f32>>();

        // Check overall match to reference output to catch phase error, etc
        (0..CUTOFF_TEST_INPUT.len()).for_each(|i| { let expected = CUTOFF_TEST_OUTPUT[i]; let rel_err = (out[i] - expected).abs() / expected.abs().max(1e-4); assert!(rel_err < 0.05); });
        // Check approximate attenuation at cutoff frequency; should be -3dB or 1/sqrt(2) magnitude
        let maxmag = out.iter().fold(0.0_f32, |a, b| a.abs().max(b.abs()));
        let attenuation_rel_err = (maxmag - 0.707).abs() / 0.707;
        println!("order {order} attenuation rel err {attenuation_rel_err}");
        assert!(attenuation_rel_err < 0.05);

        // Check convergence of step responses at min and max tabulated cutoff
        let mut filtermin = butter1(MIN_CUTOFF_RATIO).unwrap();
        (0..99999).for_each(|_| {filtermin.update(1.0);});
        let step_min_final = filtermin.update(1.0);
        let step_min_rel_err = (step_min_final - STEP_TEST_MIN_OUTPUT).abs() / STEP_TEST_MIN_OUTPUT;
        println!("order {order} step min rel err {step_min_rel_err}");
        assert!(step_min_rel_err < 1e-4);


    // Check response of staged filter
    let mut filter_2stage = butter1_2stage(0.1).unwrap();
    let mut maxmag_2stage = 0.0;
    for i in 0..99999 {
        let u = libm::sinf((i as f32) * 2.0 * core::f32::consts::PI / 10.0);
        let v = filter_2stage.update(u);
        maxmag_2stage = v.abs().max(maxmag_2stage);
    }
    let attenuation_2stage_rel_err = (maxmag_2stage - 0.707).abs() / 0.707;
    println!("order {order} attenuation 2stage rel err {attenuation_rel_err}");
    assert!(attenuation_2stage_rel_err < 0.05);

    let mut filtermin_2stage = butter1_2stage(MIN_CUTOFF_RATIO).unwrap();
    (0..99999).for_each(|_| {filtermin_2stage.update(1.0);});
    let step_min_2stage_final = filtermin_2stage.update(1.0);
    let step_min_2stage_rel_err = (step_min_2stage_final - STEP_TEST_MIN_OUTPUT).abs() / STEP_TEST_MIN_OUTPUT;
    println!("order {order} step min 2stage rel err {step_min_2stage_rel_err}");
    assert!(step_min_2stage_rel_err < 2e-4);  // 1e-4 per stage
    


                let mut filtermax = butter1(MAX_CUTOFF_RATIO).unwrap();
        (0..1).for_each(|_| {filtermax.update(1.0);});
        let step_max_final = filtermax.update(1.0);
        let step_max_rel_err = (step_max_final - STEP_TEST_MAX_OUTPUT).abs() / STEP_TEST_MAX_OUTPUT;
        println!("order {order} step max rel err {step_max_rel_err}");
        assert!(step_max_rel_err < 1e-6);
    }
}
