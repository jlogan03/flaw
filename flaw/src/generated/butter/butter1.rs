//! Butterworth filter of order 1.
//! Region of validity: cutoff ratio from 1.00e-04 to 4.00e-01 .
//! This file is autogenerated.
#![allow(clippy::style)]

use crate::{SisoIirFilter, StagedSisoIirFilter};

/// Minimum tabulated cutoff ratio
#[allow(dead_code)]
pub const MIN_CUTOFF_RATIO: f64 = 0.0001;

/// Maximum tabulated cutoff ratio
#[allow(dead_code)]
pub const MAX_CUTOFF_RATIO: f64 = 0.4;

/// Initialise a Butterworth filter of order 1 by interpolating the coefficients from stored tables.
/// Cutoff ratio is the dimensionless ratio of the cutoff frequency to the sampling frequency.
/// Region of validity: cutoff ratio from 1.00e-04 to 4.00e-01
pub fn butter1(cutoff_ratio: f64) -> Result<SisoIirFilter<1>, &'static str> {
    let avals = &[&AVALS[0][..]];
    let cvals = &[&CVALS[0][..]];
    SisoIirFilter::new_interpolated(cutoff_ratio, &LOG10_CUTOFF_RATIOS, avals, cvals, &DVALS)
}

/// Initialise a two-stage Butterworth filter of combined order 2*1 by interpolating the coefficients from stored tables.
/// Cutoff ratio is the dimensionless ratio of the cutoff frequency to the sampling frequency.
/// Region of validity: cutoff ratio from 5.61e-05 to 3.45e-01
pub fn butter1_2stage(cutoff_ratio: f64) -> Result<StagedSisoIirFilter<1, 2>, &'static str> {
    // Look up the per-stage cutoff ratio corresponding to the desired combined cutoff
    let log10_root_cutoff_ratio = libm::log10(cutoff_ratio);

    if log10_root_cutoff_ratio < LOG10_ROOT2_CUTOFF_RATIOS[0]
        || log10_root_cutoff_ratio > *LOG10_ROOT2_CUTOFF_RATIOS.last().ok_or("Table size error")?
    {
        return Err("Selected cutoff ratio is outside the grid");
    }

    let log10_cutoff_ratio = interpn::MulticubicRectilinear::<'_, _, 1>::new(
        &[&LOG10_ROOT2_CUTOFF_RATIOS],
        &LOG10_CUTOFF_RATIOS,
        true,
    )?
    .interp_one(&[log10_root_cutoff_ratio])?;
    let cutoff_ratio = libm::pow(10.0, log10_cutoff_ratio);
    let filt = butter1(cutoff_ratio)?;
    Ok(StagedSisoIirFilter::new([filt, filt]))
}

/// [dimensionless] Log base-10 of cutoff ratios, to improve float precision during interpolation
#[rustfmt::skip]
static LOG10_CUTOFF_RATIOS: [f64; 30] = [-4.0, -3.8757910347817943, -3.7515820695635886, -3.6273731043453834, -3.5031641391271777, -3.378955173908972, -3.2547462086907664, -3.1305372434725607, -3.0063282782543554, -2.8821193130361493, -2.757910347817944, -2.6337013825997384, -2.5094924173815327, -2.3852834521633275, -2.2610744869451214, -2.136865521726916, -2.0126565565087104, -1.8884475912905048, -1.764238626072299, -1.6400296608540939, -1.5158206956358882, -1.3916117304176825, -1.2674027651994768, -1.1431937999812711, -1.0189848347630655, -0.8947758695448602, -0.7705669043266545, -0.6463579391084489, -0.5221489738902432, -0.3979400086720376];

/// [dimensionless] Log base-10 of root cutoff ratios, used to generate multi-stage filters
#[rustfmt::skip]
static LOG10_ROOT2_CUTOFF_RATIOS: [f64; 30] = [-4.250797563741432, -4.078668147294895, -3.9418510541712406, -3.8186670475804414, -3.694458046856834, -3.5702490187294162, -3.4460399420479053, -3.3218307793374837, -3.197621464199902, -3.073411878989535, -2.9492018152599453, -2.8249909036812357, -2.7007784898648994, -2.5765634143406104, -2.4523436226934447, -2.3281154747262995, -2.203872520195112, -2.079603328917485, -1.9552876438582316, -1.8308895579575675, -1.7063454021429578, -1.5815422134557928, -1.4562793553731115, -1.330199773068116, -1.2026657249113235, -1.072530147353366, -0.937702247974866, -0.7943067202475265, -0.6360009029145015, -0.4627638135196929];

/// State-Space `D` 1x1 matrix
#[rustfmt::skip]
static DVALS: [f64; 30] = [0.0003140606106404424, 0.00041800097016816805, 0.0005563219213028678, 0.000740380864040595, 0.000985275681384651, 0.0013110679024855197, 0.0017443991308080233, 0.002320622014797549, 0.003086600452945956, 0.004104373205603521, 0.005455919055572824, 0.007249305608815886, 0.009626537938435431, 0.012773428747117956, 0.01693175561564251, 0.022413800171662092, 0.029619001703931738, 0.03905180975139148, 0.05133881144939779, 0.06724188546767283, 0.08766288304609028, 0.11363528543000626, 0.14630187676186024, 0.1868890944985657, 0.23671544645277764, 0.29732562727871686, 0.3709566057505938, 0.46184606924699706, 0.580004822638173, 0.7547627247472144];

/// State-Space `A` matrix, first row
#[rustfmt::skip]
static AVALS: [[f64; 30]; 1] = [[0.9993718787787192, 0.9991639980596637, 0.9988873561573944, 0.9985192382719189, 0.9980294486372305, 0.9973778641950289, 0.9965112017383839, 0.995358755970405, 0.9938267990941081, 0.9917912535887929, 0.9890881618888542, 0.9855013887823683, 0.9807469241231291, 0.9744531425057641, 0.9661364887687149, 0.9551723996566759, 0.9407619965921366, 0.9218963804972171, 0.8973223771012045, 0.8655162290646543, 0.8246742339078192, 0.7727294291399873, 0.7073962464762794, 0.6262218110028686, 0.5265691070944447, 0.4053487454425664, 0.25808678849881234, 0.07630786150600581, -0.16000964527634612, -0.5095254494944288]];

/// State-Space `C` vector
#[rustfmt::skip]
static CVALS: [[f64; 30]; 1] = [[0.0006279239531465732, 0.0008356524907142131, 0.0011120248544454914, 0.0014796654004335151, 0.001968609826432646, 0.002618698006881184, 0.0034827124049609188, 0.004630473456523973, 0.00615414670117966, 0.00817505465238529, 0.010852304005663723, 0.014393506354011754, 0.01906773541151059, 0.02522053653032051, 0.033290142534829335, 0.043822843467053785, 0.05748343288398845, 0.0750535318130652, 0.09740627577672195, 0.12544082861285039, 0.15995620396427554, 0.20144461467049452, 0.24979527523563538, 0.30392312171214375, 0.3613624877268796, 0.41784619728406885, 0.4666956048011846, 0.4970885551361901, 0.48719845670926887, 0.37019190815875014]];

#[cfg(feature = "std")]
#[cfg(test)]
#[rustfmt::skip]
mod test {
    use super::*;
    static CUTOFF_TEST_INPUT: [f32; 101] = [0.0, 0.5877852522924732, -0.9510565162951536, 0.9510565162951535, -0.5877852522924728, -4.898587196589413e-16, 0.5877852522924736, -0.9510565162951538, 0.9510565162951533, -0.5877852522924725, -9.797174393178826e-16, 0.587785252292474, -0.951056516295154, 0.9510565162951532, -0.587785252292472, -1.4695761589768238e-15, 0.5877852522924744, -0.9510565162951541, 0.951056516295153, -0.5877852522924716, -1.959434878635765e-15, 0.5877852522924748, -0.9510565162951542, 0.9510565162951529, -0.5877852522924712, -2.4492935982947065e-15, 0.5877852522924751, -0.9510565162951544, 0.9510565162951528, -0.5877852522924708, -2.9391523179536475e-15, 0.5877852522924756, -0.9510565162951545, 0.9510565162951525, -0.5877852522924705, -3.429011037612589e-15, 0.587785252292476, -0.9510565162951546, 0.9510565162951524, -0.58778525229247, -3.91886975727153e-15, 0.5877852522924764, -0.9510565162951549, 0.9510565162951523, -0.5877852522924697, -4.408728476930472e-15, 0.5877852522924768, -0.951056516295155, 0.9510565162951521, -0.5877852522924693, -4.898587196589413e-15, 0.5877852522924887, -0.9510565162951552, 0.9510565162951563, -0.5877852522924688, -1.9599300631450357e-14, 0.5877852522924776, -0.9510565162951509, 0.9510565162951519, -0.5877852522924569, -5.878304635907295e-15, 0.5877852522924665, -0.9510565162951554, 0.9510565162951473, -0.587785252292468, 7.842691359635767e-15, 0.5877852522924784, -0.95105651629516, 0.9510565162951515, -0.5877852522924791, -6.858022075225178e-15, 0.5877852522924902, -0.9510565162951558, 0.9510565162951558, -0.5877852522924673, -2.1558735510086122e-14, 0.5877852522924791, -0.9510565162951515, 0.9510565162951512, -0.5877852522924554, -7.83773951454306e-15, 0.587785252292468, -0.9510565162951561, 0.9510565162951466, -0.5877852522924665, 5.883256481000002e-15, 0.5877852522924799, -0.9510565162951606, 0.9510565162951509, -0.5877852522924776, -8.817456953860943e-15, 0.5877852522924918, -0.9510565162951563, 0.9510565162951552, -0.5877852522924657, -2.3518170388721888e-14, 0.5877852522924807, -0.9510565162951521, 0.9510565162951506, -0.5877852522924538, -9.797174393178826e-15];
    static CUTOFF_TEST_OUTPUT: [f32; 101] = [0.0, 0.44363839858649595, -0.5002286634938007, 0.25487923461667605, 0.14431615245617008, -0.5171711510360325, 0.7071502617836815, -0.6344946640364608, 0.323291178894994, 0.1094585257969724, -0.49941030314419593, 0.6981006577781912, -0.6298836604878166, 0.3209417552392504, 0.11065561694121828, -0.5000202515475538, 0.6984114420125804, -0.6300420129645394, 0.3210224398561308, 0.11061450607553514, -0.4999993045152374, 0.6984007689665237, -0.6300365747759498, 0.3210196689606451, 0.1106159179173033, -0.5000000238845491, 0.6984011355034956, -0.6300367615358649, 0.3210197641195746, 0.11061586943140711, -0.49999999917975113, 0.6984011229157723, -0.6300367551220993, 0.32101976085159745, 0.11061587109652476, -0.500000000028171, 0.6984011233480638, -0.6300367553423626, 0.3210197609638271, 0.11061587103934117, -0.49999999999903455, 0.6984011233332178, -0.6300367553347981, 0.3210197609599726, 0.11061587104130527, -0.5000000000000354, 0.6984011233337277, -0.6300367553350577, 0.32101976096010454, 0.1106158710412381, -0.5000000000000013, 0.6984011233337191, -0.6300367553350443, 0.32101976096010076, 0.11061587104124365, -0.5000000000000149, 0.6984011233337064, -0.6300367553350431, 0.3210197609601001, 0.11061587104124965, -0.4999999999999985, 0.6984011233337, -0.6300367553350517, 0.32101976096009754, 0.11061587104123904, -0.49999999999999123, 0.6984011233337157, -0.6300367553350541, 0.32101976096009865, 0.11061587104123344, -0.5000000000000079, 0.698401123333722, -0.6300367553350451, 0.3210197609601003, 0.1106158710412446, -0.5000000000000157, 0.6984011233337064, -0.6300367553350426, 0.3210197609600987, 0.11061587104125092, -0.4999999999999995, 0.6984011233337002, -0.6300367553350512, 0.32101976096009627, 0.11061587104124032, -0.4999999999999922, 0.6984011233337158, -0.6300367553350534, 0.32101976096009727, 0.11061587104123471, -0.5000000000000088, 0.6984011233337222, -0.6300367553350446, 0.32101976096009915, 0.11061587104124593, -0.5000000000000165, 0.6984011233337066, -0.6300367553350418, 0.32101976096009766, 0.11061587104125231, -0.5000000000000006];
    const STEP_TEST_MIN_OUTPUT: f32 = 1.0000000000000966;
    const STEP_TEST_MAX_OUTPUT: f32 = 1.0000006694809398;

    #[test]
    fn test() {
        let order = 1;
        println!("order {order}");
        let mut filter = butter1(0.4).unwrap();
        let out = (0..CUTOFF_TEST_INPUT.len()).map(|i| {filter.update(CUTOFF_TEST_INPUT[i])}).collect::<Vec<f32>>();

        // Check overall match to reference output to catch phase error, etc
        (0..CUTOFF_TEST_INPUT.len()).for_each(|i| { let expected = CUTOFF_TEST_OUTPUT[i]; let rel_err = (out[i] - expected).abs() / expected.abs().max(1e-4); assert!(rel_err < 0.05); });
        // Check approximate attenuation at cutoff frequency; should be -3dB or 1/sqrt(2) magnitude
        let maxmag = out.iter().fold(0.0_f32, |a, b| a.abs().max(b.abs()));
        let attenuation_rel_err = (maxmag - (libm::sqrtf(2.0) / 2.0)).abs() / (libm::sqrtf(2.0) / 2.0);
        println!("order {order} attenuation rel err {attenuation_rel_err}");
        assert!(attenuation_rel_err < 0.05);

        // Check convergence of step responses at min and max tabulated cutoff
        let mut filtermin = butter1(MIN_CUTOFF_RATIO).unwrap();
        (0..99999).for_each(|_| {filtermin.update(1.0);});
        let step_min_final = filtermin.update(1.0);
        let step_min_rel_err = (step_min_final - STEP_TEST_MIN_OUTPUT).abs() / STEP_TEST_MIN_OUTPUT;
        println!("order {order} step min rel err {step_min_rel_err}");
        assert!(step_min_rel_err < 1e-4);


    // Check response of staged filter
    let freq = 0.17;
    let mut filter_2stage = butter1_2stage(freq).unwrap();
    let mut maxmag_2stage = 0.0;
    for i in 0..99999 {
        let u = libm::sin((i as f64) * 2.0 * core::f64::consts::PI * freq) as f32;
        let v = filter_2stage.update(u);
        maxmag_2stage = v.abs().max(maxmag_2stage);
    }
    let attenuation_2stage_rel_err = (maxmag_2stage - (libm::sqrtf(2.0) / 2.0)).abs() / (libm::sqrtf(2.0) / 2.0);
    println!("order {order} attenuation 2stage rel err {attenuation_2stage_rel_err}");
    assert!(attenuation_2stage_rel_err < 0.05);

    let mut filtermin_2stage = butter1_2stage(MIN_CUTOFF_RATIO).unwrap();
    (0..99999).for_each(|_| {filtermin_2stage.update(1.0);});
    let step_min_2stage_final = filtermin_2stage.update(1.0);
    let step_min_2stage_rel_err = (step_min_2stage_final - STEP_TEST_MIN_OUTPUT).abs() / STEP_TEST_MIN_OUTPUT;
    println!("order {order} step min 2stage rel err {step_min_2stage_rel_err}");
    assert!(step_min_2stage_rel_err < 2e-4);  // 1e-4 per stage
    


                let mut filtermax = butter1(MAX_CUTOFF_RATIO).unwrap();
        (0..19).for_each(|_| {filtermax.update(1.0);});
        let step_max_final = filtermax.update(1.0);
        let step_max_rel_err = (step_max_final - STEP_TEST_MAX_OUTPUT).abs() / STEP_TEST_MAX_OUTPUT;
        println!("order {order} step max rel err {step_max_rel_err}");
        assert!(step_max_rel_err < 1e-6);
    }
}
