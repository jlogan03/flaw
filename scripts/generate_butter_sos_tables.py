from pathlib import Path
from scipy.signal import butter
import numpy as np
from matplotlib import pyplot as plt


def write_rust_sos_tables(sos) -> str:
    rust_source = """#[rustfmt::skip]
static SOS_TABLES: [[[f64; NUM_INTERP_POINTS]; 5]; NUM_SECTIONS] = ["""
    for sec in range(sos.shape[0]):
        rust_source += "    [\n"
        assert np.all(sos[sec, 3, :] == 1.0)
        for i in (0, 1, 2, 4, 5):  # Omit index 3 as it is always 1.0
            rust_source += "        [" + ", ".join(str(x) for x in sos[sec, i, :]) + "],\n"
        rust_source += "    ],\n"
    rust_source += "];\n"
    return rust_source

def write_rust_source(cutoff_ratios, sos, min_cutoff_f32, min_cutoff_f64, max_cutoff) -> str:
    sections = sos.shape[0]
    order = sections * 2
    num_interp_points = sos.shape[2]
    rust_source = f"""//! Butterworth filters: pre-calculated Second Order Sections coefficients for order {order:d} lowpass filters.
//! This file is autogenerated.
use num_traits::{{FromPrimitive, MulAdd, Num, ToPrimitive}};
use crate::sos::SisoSosFilter;

pub const NUM_SECTIONS: usize = {sections};
const NUM_INTERP_POINTS: usize = {num_interp_points};
pub const MIN_CUTOFF_RATIO_F32: f64 = {min_cutoff_f32};
pub const MAX_CUTOFF_RATIO_F32: f64 = {max_cutoff};
pub const MIN_CUTOFF_RATIO_F64: f64 = {min_cutoff_f64};
pub const MAX_CUTOFF_RATIO_F64: f64 = {max_cutoff};

// [dimensionless] Log base-10 of cutoff ratios, to improve float precision during interpolation
#[rustfmt::skip]
static LOG10_CUTOFF_RATIOS: [f64; NUM_INTERP_POINTS] = [{', '.join(str(x) for x in np.log10(cutoff_ratios))}];

"""
    rust_source += write_rust_sos_tables(sos)
    rust_source += """
pub trait CutoffRatioBounds {
    const MIN_CUTOFF_RATIO: f64;
    const MAX_CUTOFF_RATIO: f64;

    fn is_within_bounds(cutoff_ratio: f64) -> bool {
        cutoff_ratio >= Self::MIN_CUTOFF_RATIO && cutoff_ratio <= Self::MAX_CUTOFF_RATIO
    }
}

"""
    rust_source += "\n".join(
f"""
impl CutoffRatioBounds for f{b} {{
    const MIN_CUTOFF_RATIO: f64 = MIN_CUTOFF_RATIO_F{b};
    const MAX_CUTOFF_RATIO: f64 = MAX_CUTOFF_RATIO_F{b};
}}
""" for b in ("32", "64"))

    rust_source += f"""
/// Butterworth order {order} lowpass filter, second order sections (SOS) implementation.
/// The filter is created by interpolating the SOS coefficients from stored tables.
///
/// `cutoff_ratio` (dimensionless) is the cutoff frequency divided by the sample frequency.
///
/// Region of validity for `cutoff_ratio` depends on the float type `T`:
/// * f32: {min_cutoff_f32:.4f} to {max_cutoff:.4f}
/// * f64: {min_cutoff_f64:.4f} to {max_cutoff:.4f}
pub fn butter{order}<T>(cutoff_ratio: f64) -> Result<SisoSosFilter<NUM_SECTIONS, T>, &'static str>
where
    T: Num + Copy + MulAdd<Output = T> + FromPrimitive + ToPrimitive + CutoffRatioBounds,
{{
    if !T::is_within_bounds(cutoff_ratio) {{
        return Err("cutoff_ratio out of bounds for provided float type");
    }}
    // Convert SOS tables from static arrays to slices because new_interpolated expects slices.
    let sos_tables = SOS_TABLES
        .each_ref()
        .map(|sec| sec.each_ref().map(|coeffs| &coeffs[..]));
    SisoSosFilter::new_interpolated(
        cutoff_ratio,
        &LOG10_CUTOFF_RATIOS,
        sos_tables,
    )
}}

#[cfg(test)]
mod tests {{
    use super::super::test_helpers::test_filter;
    use super::{{butter{order}, MAX_CUTOFF_RATIO_F32, MIN_CUTOFF_RATIO_F32, MAX_CUTOFF_RATIO_F64, MIN_CUTOFF_RATIO_F64, NUM_SECTIONS}};

"""
    rust_source += "\n\n".join(
f"""    #[test]
    fn test_butter{order}_f{b}() {{
        test_filter::<NUM_SECTIONS, f{b}>(
            MIN_CUTOFF_RATIO_F{b},
            MAX_CUTOFF_RATIO_F{b},
            butter{order},
        );
    }}""" for b in ("32", "64"))
    rust_source += "\n}\n"

    return rust_source

max_cutoff = 0.4
for (sections, min_cutoff_f32, min_cutoff_f64) in [
    (1, 0.005, 0.0020),
    (2, 0.005, 0.0005),
    (3, 0.010, 0.0005),
]:
    order = 2 * sections
    num_interp_points = 100
    # [dimensionless] Cutoff frequency / sample frequency
    cutoff_ratios = np.logspace(-4, float(np.log10(max_cutoff)), num_interp_points, endpoint=True)

    # Compute SOS coefficients for each cutoff ratio
    sos = np.zeros((sections, 6, num_interp_points))
    for i, c in enumerate(cutoff_ratios):
        sos[:, :, i] = butter(N=order, Wn=c, fs=1.0, btype="low", output="sos")

    # Generate rust code for these coefficients
    rust_source = write_rust_source(cutoff_ratios, sos, min_cutoff_f32, min_cutoff_f64, max_cutoff)
    here = Path(__file__).parent
    rust_source_path = here.parent / f"flaw/src/butter_sos/butter{order:d}.rs"
    with open(rust_source_path, "w") as rust_source_file:
        rust_source_file.write(rust_source)

    # Plot the SOS coefficients
    fig, axes = plt.subplots(2, 3, figsize=(10, 8), sharex=True)
    for sec in range(sections):
        axes[0, 0].plot(cutoff_ratios, sos[sec, 0, :], label=f"Section {sec + 1}")
        axes[0, 1].plot(cutoff_ratios, sos[sec, 1, :], label=f"Section {sec + 1}")
        axes[0, 2].plot(cutoff_ratios, sos[sec, 2, :], label=f"Section {sec + 1}")
        axes[1, 0].plot(cutoff_ratios, sos[sec, 3, :], label=f"Section {sec + 1}")
        axes[1, 1].plot(cutoff_ratios, sos[sec, 4, :], label=f"Section {sec + 1}")
        axes[1, 2].plot(cutoff_ratios, sos[sec, 5, :], label=f"Section {sec + 1}")

    axes[0, 0].set_ylabel("b0")
    axes[0, 1].set_ylabel("b1")
    axes[0, 2].set_ylabel("b2")
    axes[1, 0].set_ylabel("a0")
    axes[1, 1].set_ylabel("a1")
    axes[1, 2].set_ylabel("a2")
    for axes_row in axes:
        for ax in axes_row:
            ax.set_xscale("log")
            ax.legend()
            ax.grid(axis="both", which="major", lw=0.5, color="black")
            ax.grid(axis="x", which="minor", lw=0.2, color="black")
            ax.set_xlabel("Cutoff ratio $f_c/f_s$ [-]")

    fig.suptitle(f"SOS coefs vs cutoff ratio\nfor order {order} Butterworth lowpass filter")
    fig.tight_layout()

    # Separate plot for b0 with log-log axes
    fig_b0, ax_b0 = plt.subplots(figsize=(6,4))
    for sec in range(sections):
        ax_b0.plot(cutoff_ratios, sos[sec, 0, :], label=f"Section {sec + 1}")
    ax_b0.set_xscale("log")
    ax_b0.set_yscale("log")
    ax_b0.set_xlabel("Cutoff ratio $f_c/f_s$ [-]")
    ax_b0.set_ylabel("b0")
    ax_b0.legend()
    ax_b0.grid(axis="both", which="major", lw=0.5, color="black")
    ax_b0.grid(axis="x", which="minor", lw=0.2, color="black")
    ax_b0.set_title(f"SOS b0 coefficients vs cutoff ratio\nfor order {order} Butterworth lowpass filter")
    fig_b0.tight_layout()
plt.show()
