from pathlib import Path
from scipy.signal import butter
import numpy as np
from matplotlib import pyplot as plt


for sections in [1, 2, 3]:
    order = 2 * sections

    num_interp_points = 100
    # [dimensionless] Cutoff frequency / sample frequency
    cutoff_ratios = np.logspace(-4, float(np.log10(0.4)), num_interp_points, endpoint=True)

    # Compute SOS coefficients for each cutoff ratio
    sos = np.zeros((sections, 6, num_interp_points))
    for i, c in enumerate(cutoff_ratios):
        sos[:, :, i] = butter(N=order, Wn=c, fs=1.0, btype="low", output="sos")

    # Generate rust code for these coefficients
    rust_source = f"""//! Butterworth filters: pre-calculated Second Order Sections coefficients for order {order:d} lowpass filters.
//! This file is autogenerated.

pub const NUM_SECTIONS: usize = {sections};
pub const NUM_INTERP_POINTS: usize = {num_interp_points};

// [dimensionless] Log base-10 of cutoff ratios, to improve float precision during interpolation
#[rustfmt::skip]
pub static LOG10_CUTOFF_RATIOS: [f64; NUM_INTERP_POINTS] = [{', '.join(str(x) for x in np.log10(cutoff_ratios))}];

#[rustfmt::skip]
pub static SOS_TABLES: [[[f64; NUM_INTERP_POINTS]; 5]; NUM_SECTIONS] = [
"""
    for sec in range(sections):
        rust_source += "    [\n"
        assert np.all(sos[sec, 3, :] == 1.0)
        for i in (0, 1, 2, 4, 5):  # Omit index 3 as it is always 1.0
            rust_source += "        [" + ", ".join(str(x) for x in sos[sec, i, :]) + "],\n"
        rust_source += "    ],\n"
    rust_source += "];\n"

    here = Path(__file__).parent
    rust_source_path = here.parent / f"flaw/src/butter_sos/butter_sos_tables_{order:d}.rs"
    with open(rust_source_path, "w") as rust_source_file:
        rust_source_file.write(rust_source)

    # Plot the SOS coefficients
    fig, axes = plt.subplots(2, 3, figsize=(10, 8), sharex=True)
    for sec in range(sections):
        axes[0, 0].plot(cutoff_ratios, sos[sec, 0, :], label=f"Section {sec + 1}")
        axes[0, 1].plot(cutoff_ratios, sos[sec, 1, :], label=f"Section {sec + 1}")
        axes[0, 2].plot(cutoff_ratios, sos[sec, 2, :], label=f"Section {sec + 1}")
        axes[1, 0].plot(cutoff_ratios, sos[sec, 3, :], label=f"Section {sec + 1}")
        axes[1, 1].plot(cutoff_ratios, sos[sec, 4, :], label=f"Section {sec + 1}")
        axes[1, 2].plot(cutoff_ratios, sos[sec, 5, :], label=f"Section {sec + 1}")

    axes[0, 0].set_ylabel("b0")
    axes[0, 1].set_ylabel("b1")
    axes[0, 2].set_ylabel("b2")
    axes[1, 0].set_ylabel("a0")
    axes[1, 1].set_ylabel("a1")
    axes[1, 2].set_ylabel("a2")
    for axes_row in axes:
        for ax in axes_row:
            ax.set_xscale("log")
            ax.legend()
            ax.grid(axis="both", which="major", lw=0.5, color="black")
            ax.grid(axis="x", which="minor", lw=0.2, color="black")
            ax.set_xlabel("Cutoff ratio $f_c/f_s$ [-]")

    fig.suptitle(f"SOS coefs vs cutoff ratio\nfor order {order} Butterworth lowpass filter")
    fig.tight_layout()
plt.show()
